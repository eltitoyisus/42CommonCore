# CPP Modules 05-09

## Description

CPP modules 05-09 advance your C++ knowledge beyond the basics, covering exceptions, casts, templates, STL containers, and advanced programming patterns. These modules prepare you for complex C++ development.

## Project Overview

Through these five modules, you'll learn:
- Exception handling
- Type casting in C++
- Templates and generic programming
- STL containers and iterators
- Advanced C++ patterns
- Standard Template Library

---

## CPP Module 05

### Topics Covered
- Try/Catch blocks
- Exception handling
- Custom exceptions
- Exception specifications
- Bureaucrat exercises (forms, execution)

### Key Exercises
- **ex00**: Mommy, when I grow up, I want to be a bureaucrat!
- **ex01**: Form up, maggots!
- **ex02**: No, you need form 28B, not 28C...
- **ex03**: At least this beats coffee-making

### Exception Handling Example
```cpp
class Bureaucrat {
public:
    class GradeTooHighException : public std::exception {
        const char* what() const throw() {
            return "Grade is too high!";
        }
    };
    
    void incrementGrade() {
        if (grade - 1 < 1)
            throw GradeTooHighException();
        grade--;
    }
};

// Usage
try {
    bureaucrat.incrementGrade();
} catch (std::exception& e) {
    std::cout << e.what() << std::endl;
}
```

### Skills Acquired
- Exception throwing and catching
- Custom exception classes
- Exception safety
- RAII with exceptions
- Error handling patterns

---

## CPP Module 06

### Topics Covered
- C++ casts
- Static cast
- Dynamic cast
- Reinterpret cast
- Const cast
- Type conversion and identification

### Key Exercises
- **ex00**: Conversion of scalar types
- **ex01**: Serialization
- **ex02**: Identify real type

### The Four Casts
```cpp
// static_cast - Compile-time type conversion
int i = 42;
float f = static_cast<float>(i);

// dynamic_cast - Runtime polymorphic casting
Base* base = new Derived();
Derived* derived = dynamic_cast<Derived*>(base);

// reinterpret_cast - Low-level reinterpretation
int* ptr = &i;
uintptr_t addr = reinterpret_cast<uintptr_t>(ptr);

// const_cast - Remove const qualifier
const int ci = 42;
int* modifiable = const_cast<int*>(&ci);
```

### Skills Acquired
- Understanding C++ cast operators
- Type safety
- Serialization/deserialization
- Runtime type identification (RTTI)
- Type conversion best practices

---

## CPP Module 07

### Topics Covered
- Function templates
- Class templates
- Template specialization
- Generic programming basics

### Key Exercises
- **ex00**: Start with a few functions
- **ex01**: Iter
- **ex02**: Array

### Template Examples
```cpp
// Function template
template <typename T>
T const& max(T const& x, T const& y) {
    return (x >= y) ? x : y;
}

// Class template
template <typename T>
class Array {
private:
    T* _array;
    unsigned int _size;
public:
    Array(unsigned int n) : _size(n) {
        _array = new T[n];
    }
    T& operator[](unsigned int i) {
        return _array[i];
    }
};

// Usage
Array<int> intArray(5);
Array<std::string> strArray(10);
```

### Skills Acquired
- Template syntax and usage
- Generic programming
- Template instantiation
- Code reusability
- Type-agnostic programming

---

## CPP Module 08

### Topics Covered
- STL containers (vector, list, deque, etc.)
- Iterators
- Algorithms
- Container operations

### Key Exercises
- **ex00**: Easy find
- **ex01**: Span
- **ex02**: Mutated abomination (Stack with iterators)

### STL Container Examples
```cpp
#include <vector>
#include <list>
#include <algorithm>

// Vector
std::vector<int> vec;
vec.push_back(42);
vec.push_back(21);

// Iterators
std::vector<int>::iterator it = vec.begin();
for (; it != vec.end(); ++it) {
    std::cout << *it << std::endl;
}

// Algorithms
std::vector<int>::iterator found = std::find(vec.begin(), vec.end(), 42);
if (found != vec.end()) {
    std::cout << "Found: " << *found << std::endl;
}

// List
std::list<int> lst;
lst.push_back(1);
lst.push_front(0);
```

### Skills Acquired
- STL container usage
- Iterator concepts
- Algorithm library
- Container selection
- Range-based operations

---

## CPP Module 09

### Topics Covered
- Advanced STL containers (map, set, stack, queue)
- Container adapters
- Real-world applications
- Data structure selection
- Algorithm complexity

### Key Exercises
- **ex00**: Bitcoin Exchange (map usage)
- **ex01**: Reverse Polish Notation (stack)
- **ex02**: PmergeMe (merge-insert sort with different containers)

### Advanced Container Examples
```cpp
#include <map>
#include <stack>
#include <set>

// Map (key-value pairs)
std::map<std::string, int> ages;
ages["Alice"] = 25;
ages["Bob"] = 30;
ages.insert(std::make_pair("Charlie", 35));

// Stack (LIFO)
std::stack<int> stack;
stack.push(1);
stack.push(2);
int top = stack.top();  // 2
stack.pop();

// Set (unique sorted elements)
std::set<int> uniqueNumbers;
uniqueNumbers.insert(5);
uniqueNumbers.insert(3);
uniqueNumbers.insert(5);  // Won't be added (duplicate)
// Set contents: {3, 5}
```

### Bitcoin Exchange (ex00)
- Parse database of date-value pairs
- Store in std::map
- Process input file and calculate values
- Handle errors and edge cases

### RPN Calculator (ex01)
- Implement Reverse Polish Notation calculator
- Use std::stack for operands
- Process operators in postfix notation

### PmergeMe (ex02)
- Implement merge-insert sort algorithm
- Compare performance with different containers
- Measure sorting time
- Handle large datasets

### Skills Acquired
- Advanced container selection
- Map and set operations
- Stack and queue usage
- Algorithm implementation
- Performance analysis
- Container complexity understanding
- Real-world problem solving

---

## Common Requirements (All Modules)

### Compilation
```bash
c++ -Wall -Wextra -Werror -std=c++98 *.cpp -o program
```

### Coding Standards
- Use C++98 standard
- Orthodox Canonical Form (when applicable)
- No memory leaks
- Proper const correctness
- Follow 42 naming conventions

### Testing
```bash
# Compile
make

# Run
./program

# Check leaks
valgrind --leak-check=full ./program
```

## Key C++ Concepts (Modules 05-09)

### Exception Handling (05)
- Try-catch blocks
- Exception hierarchies
- Exception safety guarantees
- RAII pattern

### Type Casting (06)
- Four cast operators
- Type safety
- RTTI (Run-Time Type Information)
- Safe type conversions

### Templates (07)
- Generic programming
- Code reuse
- Compile-time polymorphism
- Template specialization

### STL Basics (08)
- Containers
- Iterators
- Algorithms
- Standard library patterns

### Advanced STL (09)
- Associative containers
- Container adapters
- Performance considerations
- Real-world applications

## STL Container Comparison

### Sequence Containers
- `vector` - Dynamic array (fast random access)
- `list` - Doubly linked list (fast insertion/deletion)
- `deque` - Double-ended queue (fast both ends)

### Associative Containers
- `map` - Sorted key-value pairs (unique keys)
- `set` - Sorted unique elements
- `multimap` - Sorted key-value pairs (duplicate keys)
- `multiset` - Sorted elements (duplicates allowed)

### Container Adapters
- `stack` - LIFO (Last In First Out)
- `queue` - FIFO (First In First Out)
- `priority_queue` - Heap-based priority queue

## Performance Considerations

### Time Complexity
```
Operation     vector    list     deque    map/set
Access        O(1)      O(n)     O(1)     O(log n)
Insert (end)  O(1)      O(1)     O(1)     O(log n)
Insert (mid)  O(n)      O(1)     O(n)     O(log n)
Delete        O(n)      O(1)     O(n)     O(log n)
Search        O(n)      O(n)     O(n)     O(log n)
```

## Skills Acquired (Overall)

- Advanced C++ programming
- Exception handling
- Type casting and safety
- Template programming
- STL mastery
- Generic programming
- Algorithm selection
- Performance optimization
- Real-world C++ applications
- Software design patterns
- Code organization and reusability

## Circle

**Circle 5** - Advanced C++ programming at 42 School
